var expect = require('chai').expect;
var parser = require('../../../../core/parser');
var parse = parser.parse;

// initialization block from parser
var padZero = function(num, pad){
  pad = pad || 0;
  var toPad = pad - num.toString().length;
  var retval = num;
  for (var i = 0; i < toPad; ++i){
    retval = '0' + retval;
  }
  return retval;
}

var reltime = function (date_object, time_notation) {
  /* toks maps units to milliseconds scaling value */
  var toks = {
      /* 24*60*60*1000 */
      d: 86400000,
      dy: 86400000,
      day: 86400000,
      days: 86400000,
      /* 60*60*1000 */
      h: 3600000,
      hr: 3600000,
      hour: 3600000,
      hours: 3600000,
      /* 60*1000 */
      m: 60000,
      min: 60000,
      minute: 60000,
      minutes: 60000,
      /* 1000 */
      s: 1000,
      sec: 1000,
      secs: 1000,
      second: 1000,
      seconds: 1000
    },
    result = date_object.valueOf(),
    tokens = time_notation.toLowerCase().split(" "),
    val = 0,
    scale = 1,
    tok,
    i = 0,
    j = 0,
    cur = -1;

  for (i = 0; i < tokens.length; i += 1) {
    tok = false;
    if (Number(tokens[i])) {
      val = tokens[i];
    } else {
      cur = tokens[i].match(/[a-z]/);
      if (cur) {
        j = cur.index;
        tok = tokens[i].substr(j);
        if (j > 0) {
          val = tokens[i].substr(0, j);
        }
      } else {
        tok = tokens[i];
      }

      if (tok && val) {
        scale = toks[tok];
        result += val * scale;
        val = 0;
        tok = false;
      }
    }
  }
  return new Date(result);
};

var parseStatement = function(statement){
  /**
   * result object from this function call should have the following structure
   * {
   *   event: String,
   *   pipeline: Array,
   *   exec: {
   *     append: Array,
   *     options: {
   *       type: String,
   *       subtype: String,
   *       labels: Array
   *     }
   *   }
   *   statement: String
   * }
   */
  var result = parse(statement);
  result.statement = statement;
  return result;
}

/**
 * This files tests the parser generated by PEGjs.
 * Our goal here is to make sure the parser generates a correct object which
 * the application will use to build a query to pass to mongoose, then to mongo.
 */

describe('Parser', function(){

  it('event("bought gacha").count()', function(){
    var res = parseStatement('event("bought gacha").count()');
    expect(res.event).to.equal('bought gacha');
    expect(res.pipeline).to.be.empty();
    expect(res.exec.append).to.deep.equal([ { $group: { _id: null, value: { $sum: 1 } } } ]);
  });

  it('event("bought gacha").where({ "data.price": 100 }).count()', function(){
    var res = parseStatement('event("bought gacha").where({ "data.price": 100 }).count()');
    expect(res.event).to.equal('bought gacha');
    expect(res.pipeline).to.deep.equal([ { $match: { 'data.price': 100 } } ]);
    expect(res.exec.append).to.deep.equal([ { $group: { _id: null, value: { $sum: 1 } } } ]);
  });

  // (!) this test might fail due to the timestamp difference in the parser and in this test
  // it('event("bought gacha").from("-7d").count()', function(){
  //   var res = parseStatement('event("bought gacha").from("-7d").count()');
  //   expect(res.event).to.equal('bought gacha');
  //   expect(res.pipeline).to.deep.equal([ { $match: { timestamp: { $gte: reltime(new Date, "-7d") } } }]);
  //   expect(res.exec.append).to.deep.equal([ { $group: { _id: null, value: { $sum: 1 } } } ]);
  // });

  // number of groups by price, a pretty useless metric
  it('event("bought gacha").group({ _id: "$data.price", value: { $sum: "$data.price" } }).project({ label: "$_id", value: "$value" }).count()', function(){
    var res = parseStatement('event("bought gacha").group({ _id: "$data.price", value: { $sum: "$data.price" } }).project({ label: "$_id", value: "$value" }).count()');
    expect(res.event).to.equal('bought gacha');
    expect(res.pipeline).to.deep.equal([
      { $group: { _id: "$data.price", value: { $sum: "$data.price" } } },
      { $project: { label: "$_id", value: "$value" } }
    ]);
    expect(res.exec.append).to.deep.equal([ { $group: { _id: null, value: { $sum: 1 } } } ]);
  });

  // a pie chart to show relative size of purchases at different price points
  it('event("bought gacha").group({ _id: "$data.price", value: { $sum: 1 } }).project({ label: "$_id", value: "$value" }).chart("pie", "label", "value")', function(){
    var res = parseStatement('event("bought gacha").group({ _id: "$data.price", value: { $sum: 1 } }).project({ label: "$_id", value: "$value" }).chart("pie", "label", "value")');
    expect(res.event).to.equal('bought gacha');
    expect(res.pipeline).to.deep.equal([
      { $group: { _id: "$data.price", value: { $sum: 1 } } },
      { $project: { label: "$_id", value: "$value" } }
    ]);
    expect(res.exec.append).to.deep.equal([
      { $project: { label: '$label', value: '$value' } }
    ]);
    expect(res.exec.options).to.deep.equal({
      type: 'chart',
      subtype: 'pie',
      labels: []
    });
  });

  // it('event("bought gacha").groupBy({ year: 1, month: 1, value: { $sum: "$data.price" } }).count()', function(){
  //   var res = parseStatement('event("bought gacha").groupBy({ year: 1, month: 1, value: { $sum: "$data.price" } }).count()');
  //   expect(res.event).to.equal('bought gacha');
  //   expect(res.pipeline).to.deep.equal([
  //     {
  //       $project:
  //       {
  //         timeGroup: { year: { $year: '$timestamp' }, month: { $month: '$timestamp' } },
  //         data: 1
  //       }
  //     },
  //     { $group: { _id: '$timeGroup', value: { $sum: '$data.price' } } },
  //     { $sort: { '_id': 1 } },
  //     { $project: { label: '$_id', value: '$value' } }
  //   ]);
  //   expect(res.exec.append).to.deep.equal([
  //     { $group: { _id: null, value: { $sum: 1 } } }
  //   ]);
  // });
});